# Requirements

#### As a minimum viable product, ToyNet must be able to:
* Define a basic network configuration of routers, switches, hosts (no modern devices like switch-routers)
* Visualize the defined network configuration
* Demonstrate responses to simple unix commandline interactions made to specified hosts (includes communication with other hosts on the network)
* Run without access to internet (prison)

#### Some bonus features include:
* Protect the user from typos or invalid configurations
* Use the exact syntax of a real unix system (`host1> ping host2` instead of `mininet> host1 ping host2`)
* Handle multiple users without a noticable delay as a web hosted service
* Host accounts and record configurations per user to reinstantiate in the future

# ToyNet System Design

## MVP

My initial design for this system is very simple: a full-stack web application with a React frontend and Django backend running on Ubuntu. Since most of our instructors use a Mac or Windows machine, it will most likely run on an a virtual machine.

#### Backend Technologies

After exploring neat repositories and recieving some recommendations from others, I identified two pre-existing projects to help me accomplish these requirements:

* [Mininet](https://github.com/mininet/mininet) emulates a complete network of hosts, links, and switches on a single machine. Stanford researchers Bob Lanz and Brandon Heller initially implemented Mininet to [research](https://github.com/mininet/mininet/wiki/Publications) Software Defined Networks (SDNs).
* [Diagrams](https://diagrams.mingrammer.com) neatly organizes and stylizes cloud architecture diagrams. Implimented by MinJae Kwon, Diagrams is now GitPitch is a markdown presentation service for developers. Diagrams is now integrated as [Cloud Diagram Widget](https://gitpitch.com/docs/diagram-features/cloud-diagrams/) of [GitPitch](https://gitpitch.com/).

<img src="/images/toynet_architecture.png" />

## Frontend

We have 3 basic components:
* network visualization (image)
* text interface to construct netowrk configurations
* text interface to interact directly with the Mininet instance

## Backend

The service takes a network configuration and returns a PNG image representing current network as well as a session key. The session key is used by the frontend to indicate the Mininet instance with which to execute follow-up commands. In the first implementation, this stateful service handles one instance at a time; creating and launching a new network implies killing the currently running instance.

During network creation and updates:
1. The service creates an intermediary representation from the Mininet state to feed into Diagrams.
2. This intermediate state will compute subnets and run some validations.
3. A diagram will be generated by translating the intermediate state into a series of commands in the Diagrams DSL.

There is no decision yet on what should occur if the mininet instance goes into a error state. Should the service propagate the error message respawn an identical configuration?

## Thoughts for Bonus Features:

1. If we have multiple concurrent users as in a web application setup, destroying the current mininet session to spawn a new session would result in terminating one user's session early to service another user.
2. To enable users to create an account and save past network designs, we must store each configuration they create in a database, most likely an RDS.
3. We can enable parallel processing to handle load, but as far as I have seen, Mininet isn't specifically designed to run multiple processes on a single computing enviornment, so there will need to be further research on distributing within a single worker node.
4. Distributing across instances sounds straight forward but costly. If past network designs are accessible, we must take proper precautions when a single user accesses the network from different devices or browser tabs. The workers will need to be stateless.

# Basic Wireframes

[Higher Fidelity Wireframes](https://docs.google.com/presentation/d/1qBIG4n3aiZ1wWQHOhJnE9b4o7gJcFZxrZSS6WbfhKyI/edit#slide=id.g71e07b3188_0_3115)

## Phase 0: Proof of Concept
<span><img src="/images/wireframe_mvp.png" height="250" width="400"/></span>

## Phase 1: Text-based Network Builder
<span>
<img src="/images/wireframe_text_config.png" height="250" width="400"/>
<img src="/images/wireframe_text_console.png" height="250" width="400"/>
</span>

## Phase 2: Modify Network Builder to be GUI-based
<span>
<img src="/images/wireframe_gui_config.png" height="250" width="400"/>
<img src="/images/wireframe_gui_link.png" height="250" width="400"/>
<img src="/images/wireframe_gui_launched.png" height="250" width="400"/>
</span>

## Phase 3: Modify Console Tab to be Host-Specific
<span>
<img src="/images/wireframe_cli_ping.png" height="250" width="400"/>
<img src="/images/wireframe_cli_arp.png" height="250" width="400"/>
</span>

## Phase 4: Add History Tab
<span>
<img src="/images/wireframe_cli_history.png" height="250" width="400"/>
</span>

